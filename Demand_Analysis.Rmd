---
title: "Demand_Analysis"
output: html_document
date: "2024-04-28"
---

Install packages
```{r}
library(dplyr)
library(tidyr)
library(lavaan)
library(ggplot2)
library(scatterplot3d)
```


Initializing the dataset
```{r}
# Read the data
data <- read.csv("raw_data/surveytesttest.csv", skip = 3, header = FALSE, na.strings = c("", " "), stringsAsFactors = FALSE)

# View the modified data
head(data)
```

Renaming the headers of the dataset for ease of use
```{r}
# Read the data
colnames(data) <- c("Familiarity", "WillingnessToTry", "Interest", "FlyingExperience", "AirshowExperience","PerceivedReliability", "EnvironmentalConcern", "WillingnessToPay", "ImportanceOfTimeSavings","ImportanceOfTrafficAvoidance", "ImportanceOfConvenience", "ImportanceOfEnvBenefits","ComfortWithFlying", "MainConcern", "DemonstrationInterest", "AAMUseCases", "OhioTesting","AgeGroup", "IncomeLevel", "AreaType")

# View the modified data
head(data)
#view(data)
#write.csv(data, "modified_data.csv", row.names = FALSE)
```

jasnsak
```{r}
# Convert WillingnessToTry, Interest, PerceivedReliability, EnvironmentalConcern, and ComfortWithFlying
factor_vars <- c("WillingnessToTry", "Interest", "PerceivedReliability", "EnvironmentalConcern", "ComfortWithFlying")
level_mapping <- c("Extremely unlikely" = -2, "Somewhat unlikely" = -1, "Neutral" = 0, "Somewhat likely" = 1, "Extremely likely" = 2,
                   "Extremely uninterested" = -2, "Somewhat uninterested" = -1, "Somewhat interested" = 1, "Extremely interested" = 2,
                   "Extremely unreliable" = -2, "Somewhat unreliable" = -1, "Somewhat reliable" = 1, "Extremely reliable" = 2,
                   "Not at all important" = -2, "Slightly important" = -1, "Moderately important" = 0, "Very important" = 1, "Extremely important" = 2,
                   "Extremely uncomfortable" = -2, "Somewhat uncomfortable" = -1, "Neither comfortable nor uncomfortable" = 0, "Somewhat comfortable" = 1, "Extremely comfortable" = 2)

for (var in factor_vars) {
  encoded_var <- paste0("enc_", var)
  data[[encoded_var]] <- factor(data[[var]], levels = names(level_mapping), labels = level_mapping)
}

# Convert FlyingExperience to binary (1 if any experience, 0 if none)
data$enc_FlyingExperience <- ifelse(data$FlyingExperience == "None of the above", 0, 1)

# Convert AirshowExperience, DemonstrationInterest, and OhioTesting
binary_vars <- c("AirshowExperience", "DemonstrationInterest", "OhioTesting")
for (var in binary_vars) {
  encoded_var <- paste0("enc_", var)
  data[[encoded_var]] <- factor(data[[var]], levels = c("No", "Maybe", "Yes"), labels = c(-1, 0, 1))
}

# Convert WillingnessToPay
data$enc_WillingnessToPay <- factor(data$WillingnessToPay, levels = c("No more than a regular taxi/ride-share", "Up to 25% more", "Up to 50% more", "Up to 100% more (double)", "More than double"),
                                    labels = c(0, 0.25, 0.5, 1, 2))

# Convert IncomeLevel
data$enc_IncomeLevel <- factor(data$IncomeLevel, levels = c("Less than $25,000", "$25,000 - $50,000", "$50,001 - $75,000", "$75,001 - $100,000", "$100,001 - $150,000", "Over $150,000"),
                               labels = c(1, 2, 3, 4, 5, 6))

# Convert AreaType
data$enc_AreaType <- factor(data$AreaType, levels = c("Rural", "Suburban", "Urban"), labels = c(1, 2, 3))

# Save the modified dataset to a new CSV file
write.csv(data, "modified_data_encoded.csv", row.names = FALSE)
```


Calculating Demand Latency
```{r}
# Load the modified dataset with encoded values
data <- read.csv("modified_data_encoded.csv", stringsAsFactors = FALSE)

# Define the SEM model
model <- '
  # Latent variable Demand with indicators
  Demand =~ enc_WillingnessToTry + enc_WillingnessToPay
  # Regressions on Demand
  Demand ~ ImportanceOfTimeSavings + ImportanceOfTrafficAvoidance + 
             ImportanceOfConvenience + ImportanceOfEnvBenefits
'

# Fit the SEM model
fit <- sem(model, data = data)

# View the model summary
summary(fit, fit.measures = TRUE)

# Extract standardized coefficients
standardized_coef <- parameterEstimates(fit, standardized = TRUE)$std.all

# Print the standardized coefficients
print(standardized_coef)
```

```{r}

```





Analyzing the Regression Correlation between Interest in Trying + Willingness to Pay and Willingness to Try
```{r}
# Load the modified dataset with encoded values
data <- read.csv("modified_data_encoded.csv", stringsAsFactors = FALSE)

data_no_na <- na.omit(data)

model <- lm(enc_Interest ~ enc_WillingnessToPay + enc_WillingnessToTry, data = data_no_na)

# View the model summary
summary(model)

# Extract the coefficients and R-squared
coefficients <- coef(model)
r_squared <- summary(model)$r.squared

# Print the coefficients and R-squared
print(coefficients)
print(r_squared)

3
# Create the plot
ggplot(data = data_no_na, aes(x = enc_WillingnessToPay, y = enc_Interest)) +
  geom_point(color = "blue") +  # Add points
  geom_smooth(method = "lm", se = TRUE, color = "red") +  # Add regression line
  labs(x = "Willingness to Pay More", y = "Interest in AAM") +  # Set labels
  theme_bw()  # Apply a theme (optional)

# Create the plot
ggplot(data = data_no_na, aes(x =enc_Interest , y = enc_WillingnessToTry)) +
  geom_point(color = "blue") +  # Add points
  geom_smooth(method = "lm", se = TRUE, color = "red") +  # Add regression line
  labs(x = "Interest", y = "Willingness to Try") +  # Set labels
  theme_bw()  # Apply a theme (optional)

# Create the plot
ggplot(data = data_no_na, aes(x = enc_WillingnessToPay, y = enc_WillingnessToTry)) +
  geom_point(color = "blue") +  # Add points
  geom_smooth(method = "lm", se = TRUE, color = "red") +  # Add regression line
  labs(x = "Willingness to Pay", y = "Willingness to Try") +  # Set labels
  theme_bw()  # Apply a theme (optional)

# Create a 3D scatter plot
scatterplot3d(data$enc_WillingnessToPay, data$enc_WillingnessToTry, data$enc_Interest,
              pch = 1, color = "blue",
              xlab = "Willingness to Pay More", ylab = "Willingness to Try AAM", zlab = "Interest in AAM")



ggplot(data, aes(x = enc_WillingnessToPay, y = enc_WillingnessToTry, size = enc_Interest, color = enc_Interest)) +
  geom_point(alpha = 0.7) +  # Adjust transparency for better visibility
  scale_size(range = c(2, 8)) +  # Control the size range of the points
  scale_color_gradient(low = "blue", high = "red") +  # Set color gradient
  labs(x = "Willingness to Pay More", y = "Willingness to Try AAM",
       size = "Interest in AAM", color = "Interest in AAM") +
  theme_bw()

ggplot(data, aes(x = enc_WillingnessToPay, y = enc_WillingnessToTry)) +
  geom_bin2d(bins = 10) +  # Create a 2D binning for density estimation
  scale_fill_gradient(low = "white", high = "blue") +  # Set color gradient
  geom_density2d(color = "black") +  # Add contour lines
  labs(x = "Willingness to Pay More", y = "Willingness to Try AAM") +
  theme_bw()

library(plotly)

# Create 3D scatter plot
plot_ly(data_no_na, x = ~enc_WillingnessToPay, y = ~enc_WillingnessToTry, z = ~enc_Interest,
        type = "scatter3d", mode = "markers",
        marker = list(size = 4, color = "blue")) %>%
  layout(scene = list(xaxis = list(title = "Willingness to Pay More"),
                      yaxis = list(title = "Willingness to Try AAM"),
                      zaxis = list(title = "Interest in AAM")))

# Adding a plane is more complex and requires additional calculations 
# and manipulation of 3D mesh objects. 

library(plotly)

plot_ly(data_no_na, x = ~enc_WillingnessToPay, y = ~enc_WillingnessToTry, z = ~enc_Interest,
        type = "scatter3d", mode = "markers",
        marker = list(size = ~enc_Interest * 3,  # Scale size based on interest
                      color = ~enc_Interest, colorscale = "Viridis", showscale = TRUE)) %>%  # Set color gradient
  layout(scene = list(xaxis = list(title = "Willingness to Pay More"),
                      yaxis = list(title = "Willingness to Try AAM"),
                      zaxis = list(title = "Interest in AAM")))

library(rgl)

# Fit a linear regression model with all three variables
model_3d <- lm(enc_Interest ~ enc_WillingnessToPay + enc_WillingnessToTry, data = data_no_na)

# Create the 3D scatter plot
scatterplot3d(data$enc_WillingnessToPay, data$enc_WillingnessToTry, data$enc_Interest,
              pch = 16, color = "blue",
              xlab = "Willingness to Pay More", ylab = "Willingness to Try AAM", zlab = "Interest in AAM")


# Remove rows with missing values
data <- data_no_na <- na.omit(data) 

# Generate coordinates for the fitted plane
x_grid <- seq(min(data$enc_WillingnessToPay), max(data$enc_WillingnessToPay), length.out = 10)
y_grid <- seq(min(data$enc_WillingnessToTry), max(data$enc_WillingnessToTry), length.out = 10)
plane_grid <- expand.grid(x_grid, y_grid)
names(plane_grid) <- c("enc_WillingnessToPay", "enc_WillingnessToTry")
plane_grid$enc_Interest <- predict(model_3d, newdata = plane_grid)

# Add the fitted plane to the plot
surf3d(x_grid, y_grid, plane_grid$enc_Interest, alpha = 0.5, col = "grey")
```


MIDPOINNNNNNNT
```{r}
#Plot the coefficient 
1
# Plot relationship between willingness to pay and interest
plot(data$enc_WillingnessToPay, data$enc_Interest, 
     xlab = "Willingness to Pay More", ylab = "Interest in AAM")
abline(model, col = "red")

# Plot relationship between willingness to try and interest
plot(data$enc_WillingnessToTry, data$enc_Interest, 
     xlab = "Willingness to Try AAM", ylab = "Interest in AAM")
abline(model, col = "blue")


2
# Install and load the scatterplot3d package
# Create a 3D scatter plot
scatterplot3d(data$enc_WillingnessToPay, data$enc_WillingnessToTry, data$enc_Interest,
              pch = 16, color = "blue",
              xlab = "Willingness to Pay More", ylab = "Willingness to Try AAM", zlab = "Interest in AAM")

# Add regression plane (optional, requires additional calculations)
# ...

```


Analyzing the Regression Correlation for Public Acceptance
```{r}
# Load the modified dataset with encoded values
data <- read.csv("modified_data_encoded.csv", stringsAsFactors = FALSE)

data_no_na <- na.omit(data)

model <- lm(enc_Interest ~ enc_WillingnessToPay, data = data_no_na)

# View the model summary
summary(model)

# Extract the coefficients and R-squared
coefficients <- coef(model)
r_squared <- summary(model)$r.squared

# Print the coefficients and R-squared
print(coefficients)
print(r_squared)
```


Analyzing the Regression Correlation between Interest in Trying + Willingness to Try
```{r}
# Load the modified dataset with encoded values
data <- read.csv("modified_data_encoded.csv", stringsAsFactors = FALSE)

data_no_na <- na.omit(data)

model <- lm(enc_Interest ~ enc_WillingnessToTry, data = data_no_na)

# View the model summary
summary(model)

# Extract the coefficients and R-squared
coefficients <- coef(model)
r_squared <- summary(model)$r.squared

# Print the coefficients and R-squared
print(coefficients)
print(r_squared)
plot(model)

# Create the plot
ggplot(data = data_no_na, aes(x = enc_WillingnessToPay, y = enc_Interest)) +
  geom_point(color = "blue") +  # Add points
  geom_smooth(method = "lm", se = TRUE, color = "red") +  # Add regression line
  labs(x = "Willingness to Pay More", y = "Interest in AAM") +  # Set labels
  theme_bw()  # Apply a theme (optional)

```


Analyzing the Regression Correlation between Willingness to Pay and Willingness to Try
```{r}
# Load the modified dataset with encoded values
data <- read.csv("modified_data_encoded.csv", stringsAsFactors = FALSE)

data_no_na <- na.omit(data)

model <- lm(enc_Interest ~ enc_WillingnessToPay + enc_WillingnessToTry, data = data_no_na)

# View the model summary
summary(model)

# Extract the coefficients and R-squared
coefficients <- coef(model)
r_squared <- summary(model)$r.squared

# Print the coefficients and R-squared
print(coefficients)
print(r_squared)
```



Convience v. Everything Else
```{r}
library(ggplot2)
library(dplyr)
library(tidyr)

# Reshape data to long format with category and rank columns
data_long <- data %>%
  pivot_longer(cols = starts_with("ImportanceOf"),
               names_to = "category",
               values_to = "rank")

# Option 1: Bar Chart with Ranked Order

# Calculate average rankings and order
ranked_data <- data_long %>%
  group_by(category) %>%
  summarize(average_rank = mean(rank)) %>%
  arrange(desc(average_rank))

# Create bar chart
ggplot(ranked_data, aes(x = reorder(category, -average_rank), y = average_rank)) +
  geom_bar(stat = "identity", fill = "skyblue") +
  labs(x = "", y = "Average Rank", title = "Ranking of AAM Benefits") +
  theme_bw() +
  coord_flip()  # Flip coordinates for better readability

# Option 2: Diverging Stacked Bar Chart

# Calculate percentages of each rank
ranked_percentage <- data_long %>%
  group_by(category, rank) %>%
  summarize(percentage = n() / nrow(data_long)) %>%
  mutate(rank = factor(rank, levels = 4:1))  # Order ranks from highest to lowest

# Create diverging stacked bar chart
ggplot(ranked_percentage, aes(x = category, y = percentage, fill = rank)) +
  geom_bar(stat = "identity") +
  labs(x = "", y = "Percentage of Respondents", title = "Distribution of AAM Benefit Rankings") +
  theme_bw() +
  scale_fill_brewer(palette = "RdYlBu")  # Use diverging color palette



# ... (data reshaping code remains the same)

# Option 1: Bar Chart with Ranked Order (Flipped)

# Calculate average rankings and order
ranked_data <- data_long %>%
  group_by(category) %>%
  summarize(average_rank = mean(rank)) %>%
  arrange(desc(average_rank))

# Create bar chart with flipped coordinates
ggplot(ranked_data, aes(x = average_rank, y = reorder(category, average_rank), fill = category)) +
  geom_bar(stat = "identity") +
  labs(x = "Average Rank", y = "", title = "Ranking of AAM Benefits") +
  theme_bw() 

# Option 2: Diverging Stacked Bar Chart (Flipped)

# Calculate percentages of each rank
ranked_percentage <- data_long %>%
  group_by(category, rank) %>%
  summarize(percentage = n() / nrow(data_long)) %>%
  mutate(rank = factor(rank, levels = 4:1))  # Order ranks from highest to lowest

# Create diverging stacked bar chart with flipped coordinates
ggplot(ranked_percentage, aes(x = rank, y = percentage, fill = category)) +
  geom_bar(stat = "identity") +
  labs(x = "Rank", y = "Percentage of Respondents", title = "Distribution of AAM Benefit Rankings") +
  theme_bw() +
  scale_fill_brewer(palette = "RdYlBu")  # Use diverging color palette


# Install and load the required packages
library(ggplot2)
library(dplyr)

# Load the modified dataset with encoded values
data <- read.csv("modified_data_encoded.csv", stringsAsFactors = FALSE)

# Create a new dataset with only the top-ranked factor for each respondent
data_top_rank <- data %>%
  mutate(TopRank = case_when(
    ImportanceOfTimeSavings == 1 ~ "Time Savings",
    ImportanceOfTrafficAvoidance == 1 ~ "Traffic Avoidance",
    ImportanceOfConvenience == 1 ~ "Convenience",
    ImportanceOfEnvBenefits == 1 ~ "Environmental Benefits",
    TRUE ~ NA_character_
  )) %>%
  filter(!is.na(TopRank))

# Count the number of respondents for each top-ranked factor
data_top_rank_count <- data_top_rank %>%
  count(TopRank)

# Create a bar chart of the top-ranked factors
ggplot(data_top_rank_count, aes(x = TopRank, y = n)) +
  geom_bar(stat = "identity", fill = "steelblue") +
  labs(x = "Factor", y = "Number of Respondents",
       title = "Distribution of Top-Ranked Factors") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

# ... (data reshaping and filtering code remains the same)

# Calculate counts and percentages
top_ranked_summary <- top_ranked_data %>%
  group_by(category) %>%
  summarize(count = n()) %>%
  mutate(percentage = count / sum(count) * 100) %>%  # Calculate percentage
  arrange(percentage)  # Order by percentage

# Create bar chart with desired style
ggplot(top_ranked_summary, aes(x = reorder(category, percentage), y = percentage)) +
  geom_bar(stat = "identity", fill = "steelblue") +  # Change fill color
  labs(x = "Factor", y = "Percentage of Respondents", 
       title = "Distribution of Top-Ranked Factors") +  # Adjust labels and title
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))  # Rotate x-axis labels
```

